[
  {
    "story": "[Theresa] was so proud of her daughter [Amanda] for getting straight A's this semester. [Michelle] was excited for today, its her daughter's, [Theresa], spring break. She will finally get to see her.",
    "query": "('Amanda', 'Michelle')",
    "pyro_code": "import pyro\nimport pyro.distributions as dist\nimport torch\n\ndef relationship_model():\n    # Define the relationships and assign probabilities\n    relationships = ['mother', 'daughter', 'sister', 'aunt', 'cousin', 'grandmother', 'granddaughter']\n    rel_probs = torch.ones(len(relationships)) / len(relationships)\n\n    # Sample a relationship based on the probabilities\n    rel = pyro.sample(\"relationship\", dist.Categorical(probs=rel_probs))\n    return relationships[rel.item()]\n\n# Inference\ndef infer_relationship():\n    inferred_relationships = [relationship_model() for _ in range(1000)]\n    relationship_counts = {rel: inferred_relationships.count(rel) for rel in set(inferred_relationships)}\n    most_likely_relationship = max(relationship_counts, key=relationship_counts.get)\n    return most_likely_relationship\n\nmost_likely_relationship = infer_relationship()\n\ndef get_relationship(person1, person2):\n    # Define the relationships in the story\n    relationships = {\n        ('Theresa', 'Amanda'): 'mother-daughter',\n        ('Michelle', 'Theresa'): 'sister'\n    }\n\n    # Check if the relationship exists in the story\n    if (person1, person2) in relationships:\n        return relationships[(person1, person2)]\n    elif (person2, person1) in relationships:\n        return relationships[(person2, person1)]\n    else:\n        return 'unknown'\n\nrelationship_query = ('Amanda', 'Michelle')\nrelationship = get_relationship(relationship_query[0], relationship_query[1])\n\nprint(\"The relationship between\", relationship_query[0], \"and\", relationship_query[1], \"is:\", relationship)"
  },
  {
    "story": "[Eric] asked his son, [Michael], to go grocery shopping for him. [Michael] was busy and sent his wife, [Marlene], instead.",
    "query": "('Eric', 'Marlene')",
    "pyro_code": "Sure! Here's a Pyro code to model the relationships in the story and answer the query:\n\n```python\nimport pyro\nimport pyro.distributions as dist\nimport torch\n\ndef relationship_model():\n    # Define the relationships and assign probabilities\n    relationships = ['father', 'son', 'husband', 'wife']\n    rel_probs = torch.ones(len(relationships)) / len(relationships)\n\n    # Sample a relationship based on the probabilities\n    rel = pyro.sample(\"relationship\", dist.Categorical(probs=rel_probs))\n    return relationships[rel.item()]\n\n# Inference\ndef infer_relationship():\n    inferred_relationships = [relationship_model() for _ in range(1000)]\n    relationship_counts = {rel: inferred_relationships.count(rel) for rel in set(inferred_relationships)}\n    most_likely_relationship = max(relationship_counts, key=relationship_counts.get)\n    return most_likely_relationship\n\nmost_likely_relationship = infer_relationship()\nprint(most_likely_relationship)\n```\n\nTo answer the query ('Eric', 'Marlene'), the Pyro code models the relationships as ['father', 'son', 'husband', 'wife']. It samples a relationship based on the probabilities assigned to each relationship. In the inference step, it runs the relationship model multiple times and counts the occurrences of each relationship. Finally, it returns the most likely relationship based on the counts."
  },
  {
    "story": "[Henry]'s daughter, [Amanda], went to the city this weekend. She spent her time there visiting her grandfather, [Kyle], and had a wonderful time with him.",
    "query": "('Henry', 'Kyle')",
    "pyro_code": "import pyro\nimport pyro.distributions as dist\nimport torch\n\ndef relationship_model():\n    # Define the relationships and assign probabilities\n    relationships = ['father', 'daughter', 'grandfather']\n    rel_probs = torch.tensor([0.4, 0.4, 0.2])\n\n    # Sample a relationship based on the probabilities\n    rel = pyro.sample(\"relationship\", dist.Categorical(probs=rel_probs))\n    return relationships[rel.item()]\n\n# Inference\ndef infer_relationship():\n    inferred_relationships = [relationship_model() for _ in range(1000)]\n    relationship_counts = {rel: inferred_relationships.count(rel) for rel in set(inferred_relationships)}\n    most_likely_relationship = max(relationship_counts, key=relationship_counts.get)\n    return most_likely_relationship\n\nmost_likely_relationship = infer_relationship()\nmost_likely_relationship"
  },
  {
    "story": "[Kristen] took her son [Ronald] to [Shirley] ([Kristen]'s sister) birthday party.",
    "query": "('Shirley', 'Ronald')",
    "pyro_code": "import pyro\nimport pyro.distributions as dist\nimport torch\n\ndef relationship_model():\n    # Define the relationships and assign probabilities\n    relationships = ['mother', 'son', 'sister', 'aunt', 'cousin', 'grandmother', 'grandson']\n    rel_probs = torch.ones(len(relationships)) / len(relationships)\n\n    # Sample a relationship based on the probabilities\n    rel = pyro.sample(\"relationship\", dist.Categorical(probs=rel_probs))\n    return relationships[rel.item()]\n\ndef infer_relationship():\n    inferred_relationships = [relationship_model() for _ in range(1000)]\n    relationship_counts = {rel: inferred_relationships.count(rel) for rel in set(inferred_relationships)}\n    most_likely_relationship = max(relationship_counts, key=relationship_counts.get)\n    return most_likely_relationship\n\nmost_likely_relationship = infer_relationship()\nprint(most_likely_relationship)"
  },
  {
    "story": "[John] and his wife [Michelle], were n't getting along. [Michelle]'s father, [Henry], offered to act as a mediator.",
    "query": "('John', 'Henry')",
    "pyro_code": "Here is the Pyro Python code to model the given scenario and answer the query:\n\n```python\nimport pyro\nimport pyro.distributions as dist\nimport torch\n\ndef relationship_model():\n    # Define the relationships and assign probabilities\n    relationships = ['husband', 'wife', 'father', 'mother', 'brother', 'sister', 'uncle', 'aunt']\n    rel_probs = torch.ones(len(relationships)) / len(relationships)\n\n    # Sample a relationship based on the probabilities\n    rel = pyro.sample(\"relationship\", dist.Categorical(probs=rel_probs))\n    return relationships[rel.item()]\n\n# Inference\ndef infer_relationship():\n    inferred_relationships = [relationship_model() for _ in range(1000)]\n    relationship_counts = {rel: inferred_relationships.count(rel) for rel in set(inferred_relationships)}\n    most_likely_relationship = max(relationship_counts, key=relationship_counts.get)\n    return most_likely_relationship\n\nmost_likely_relationship = infer_relationship()\n\nprint(most_likely_relationship)\n```\n\nThe output of this code will be the most likely relationship between 'John' and 'Henry' based on the given scenario."
  },
  {
    "story": "[Karen] told her daughter [Kristen] to wash up. Dinner was ready. [Kristen] loved to care for her newborn child [Ronald].",
    "query": "('Karen', 'Ronald')",
    "pyro_code": "Sure! Here's an example of Pyro code to model the relationships in the given scenario and answer the query:\n\n```python\nimport pyro\nimport pyro.distributions as dist\nimport torch\n\ndef relationship_model():\n    # Define the relationships and assign probabilities\n    relationships = ['mother', 'daughter', 'sister', 'aunt', 'cousin', 'grandmother', 'granddaughter']\n    rel_probs = torch.ones(len(relationships)) / len(relationships)\n\n    # Sample a relationship based on the probabilities\n    rel = pyro.sample(\"relationship\", dist.Categorical(probs=rel_probs))\n    return relationships[rel.item()]\n\ndef infer_relationship(query):\n    inferred_relationships = [relationship_model() for _ in range(1000)]\n    relationship_counts = {rel: inferred_relationships.count(rel) for rel in set(inferred_relationships)}\n    return relationship_counts[query]\n\nquery = ('Karen', 'Ronald')\nrelationship_probability = infer_relationship(query)\nprint(\"Probability of relationship between {} and {} is {:.2f}%\".format(query[0], query[1], (relationship_probability / 1000) * 100))\n```\n\nNote that this code generates random relationships based on their probabilities and counts the number of times the query relationship appears among the sampled relationships. The result is then converted to a probability by dividing the count by the total number of samples (1000 in this case). The output will be the probability of the given query relationship."
  },
  {
    "story": "[Edward] and his daughter [Dorothy] are planning a trip to the mountains. They have n't been in almost 10 years. [Dorothy] has an aunt named [Theresa]",
    "query": "('Edward', 'Theresa')",
    "pyro_code": "Here is the Pyro code to model the given scenario and answer the query:\n\n```python\nimport pyro\nimport pyro.distributions as dist\nimport torch\n\ndef relationship_model():\n    relationships = ['father', 'daughter', 'sister', 'brother', 'aunt', 'uncle', 'cousin', 'grandmother', 'grandfather']\n    rel_probs = torch.ones(len(relationships)) / len(relationships)\n\n    rel = pyro.sample(\"relationship\", dist.Categorical(probs=rel_probs))\n    return relationships[rel.item()]\n\ndef infer_relationship(person1, person2):\n    inferred_relationships = [relationship_model() for _ in range(1000)]\n    relationship_counts = {rel: inferred_relationships.count(rel) for rel in set(inferred_relationships)}\n    most_likely_relationship = max(relationship_counts, key=relationship_counts.get)\n    return most_likely_relationship\n\nmost_likely_relationship = infer_relationship('Edward', 'Theresa')\nprint(most_likely_relationship)\n```\n\nIn this code, the `relationship_model` function defines the possible relationships and assigns equal probabilities to them. The `infer_relationship` function uses this model to generate 1000 samples of relationships and counts the occurrences of each relationship. Finally, it returns the most likely relationship between the two given people.\n\nYou can modify the input values `'Edward'` and `'Theresa'` in the `infer_relationship` function to answer different queries."
  },
  {
    "story": "[Kyle] who is [Eric]'s father grounded [Eric] after finding out what [Eric] had done at school. [Eric] has always felt ignored in his big family. His brother [Vernon] always got all the attention of their parents, who recounted his every accomplishment to all the household.",
    "query": "('Kyle', 'Vernon')",
    "pyro_code": "import pyro\nimport pyro.distributions as dist\nimport torch\n\ndef relationship_model(person):\n    if person == 'Kyle':\n        # Kyle is Eric's father\n        return 'father'\n    elif person == 'Eric':\n        # Eric is Vernon's brother\n        return 'brother'\n    elif person == 'Vernon':\n        # Vernon is Eric's brother\n        return 'brother'\n    else:\n        return None\n\ndef infer_relationship():\n    # Infer relationships between Kyle, Eric, and Vernon\n    relationships = [(relationship_model('Kyle'), relationship_model(person)) for person in ['Kyle', 'Vernon']]\n    return relationships\n\nrelationships = infer_relationship()\nprint(relationships)"
  },
  {
    "story": "[Theresa] loved to care for her newborn child [Darnell]. [Darnell] and his sister [Amanda] walked to school together every day, since they only lived two blocks away from the school.",
    "query": "('Theresa', 'Amanda')",
    "pyro_code": "Here is the Pyro code to model the given story and answer the query:\n\n```python\nimport pyro\nimport pyro.distributions as dist\nimport torch\n\n# Define the relationships\nrelationships = ['mother', 'father', 'brother', 'sister', 'aunt', 'uncle', 'cousin', 'grandmother', 'grandfather']\n\n# Define the probabilities for each relationship\nrelationship_probs = torch.tensor([0.25, 0.2, 0.1, 0.1, 0.05, 0.05, 0.1, 0.1, 0.05])\n\n# Define the conditional probabilities of relationships based on known information\nconditional_probs = {\n    ('Theresa', 'Darnell'): torch.tensor([0.2, 0.05, 0.05, 0.3, 0.1, 0.05, 0.1, 0.05, 0.1]),\n    ('Darnell', 'Amanda'): torch.tensor([0, 0, 0.2, 0.5, 0.1, 0, 0.05, 0, 0.15])\n}\n\n# Define the relationship model\ndef relationship_model(person1, person2):\n    if (person1, person2) in conditional_probs:\n        probs = conditional_probs[(person1, person2)]\n    else:\n        probs = relationship_probs\n\n    rel = pyro.sample(f\"{person1}_{person2}_relationship\", dist.Categorical(probs=probs))\n    return relationships[rel.item()]\n\n# Inference\ndef infer_relationship(person1, person2):\n    inferred_relationships = [relationship_model(person1, person2) for _ in range(1000)]\n    relationship_counts = {rel: inferred_relationships.count(rel) for rel in set(inferred_relationships)}\n    most_likely_relationship = max(relationship_counts, key=relationship_counts.get)\n    return most_likely_relationship\n\nquery_result = infer_relationship('Theresa', 'Amanda')\nprint(query_result)\n```\n\nThis code models the relationships using a categorical distribution with probabilities for each relationship. It also includes conditional probabilities to capture the specific relationships based on the known information in the story.\n\nThe `relationship_model` function samples a relationship based on the probabilities, with different probabilities for certain relationships when given a specific pair of people. The `infer_relationship` function repeatedly samples relationships and counts the occurrences to find the most likely relationship between two people.\n\nThe code then answers the query by calling `infer_relationship` with the names 'Theresa' and 'Amanda', and prints the result."
  },
  {
    "story": "[Sarah] was excited for today, its her daughter's, [Kristen], spring break. She will finally get to see her. [Sarah] is the [Lonnie]'s wife.",
    "query": "('Kristen', 'Lonnie')",
    "pyro_code": "import pyro\nimport pyro.distributions as dist\nimport torch\n\ndef relationship_model():\n    # Define the relationships and assign probabilities\n    relationships = ['mother', 'daughter', 'wife', 'husband']\n    rel_probs = torch.Tensor([0.4, 0.4, 0.1, 0.1])\n\n    # Sample a relationship based on the probabilities\n    rel = pyro.sample(\"relationship\", dist.Categorical(probs=rel_probs))\n    return relationships[rel.item()]\n\n# Inference\ndef infer_relationship(query):\n    inferred_relationships = [relationship_model() for _ in range(1000)]\n    relationship_counts = {rel: inferred_relationships.count(rel) for rel in set(inferred_relationships)}\n    return relationship_counts[query]\n\nrelationship = infer_relationship(('Kristen', 'Lonnie'))\nprint(relationship)"
  }
]